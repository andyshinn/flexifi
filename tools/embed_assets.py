#!/usr/bin/env python3
"""
Flexifi Asset Embedding Tool

This script converts web assets (HTML, CSS, JS) into C++ header files
for compile-time embedding in the Flexifi library.

Usage:
    python3 tools/embed_assets.py

Generated files:
    src/generated/web_assets.h - Contains all embedded assets
"""

import os
import sys
import re
from pathlib import Path

try:
    import minify_html
    MINIFY_AVAILABLE = True
except ImportError:
    MINIFY_AVAILABLE = False

def sanitize_var_name(name):
    """Convert filename to valid C++ variable name"""
    # Remove extension and convert to lowercase
    name = os.path.splitext(name)[0].lower()
    # Replace non-alphanumeric characters with underscore
    name = re.sub(r'[^a-zA-Z0-9]', '_', name)
    # Ensure it doesn't start with a number
    if name[0].isdigit():
        name = 'asset_' + name
    return name

def minify_content(content, file_extension):
    """Minify content based on file type"""
    if not MINIFY_AVAILABLE:
        return content
    
    try:
        if file_extension in ['.html', '.htm']:
            # Minify HTML with basic settings (avoid complex options that may not exist)
            return minify_html.minify(
                content,
                minify_js=False,  # Disable JS minification due to compatibility issues
                minify_css=True
            )
        elif file_extension == '.css':
            # Minify CSS by wrapping in HTML and extracting
            wrapped = f'<style>{content}</style>'
            minified_wrapped = minify_html.minify(wrapped, minify_css=True)
            # Extract the CSS content back
            import re
            match = re.search(r'<style>(.*?)</style>', minified_wrapped, re.DOTALL)
            return match.group(1) if match else content
        elif file_extension == '.js':
            # Skip JS minification for now due to compatibility issues
            # The minify-html JS minifier has issues with certain JS patterns
            return content
        else:
            return content
    except Exception as e:
        print(f"‚ö†Ô∏è Minification failed for {file_extension}: {e}")
        return content

def escape_for_raw_string(content):
    """Escape content for C++ raw string literal"""
    # Raw strings can't contain the sequence )"
    # If found, we need to change the delimiter
    # Always use a safe delimiter to avoid conflicts
    delimiter = "FLEXIFI"
    counter = 0
    
    # Find a unique delimiter that doesn't conflict with content
    while f'){delimiter}"' in content:
        counter += 1
        delimiter = f"FLEXIFI{counter}"
    
    return f'R"{delimiter}({content}){delimiter}";'

def read_file(filepath):
    """Read file content with proper encoding"""
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            return f.read()
    except UnicodeDecodeError:
        # Fallback to binary mode for non-text files
        with open(filepath, 'rb') as f:
            content = f.read()
            # Convert binary to escaped string
            return ''.join(f'\\x{b:02x}' for b in content)

def embed_file(filepath, var_name):
    """Embed a single file as a C++ constant"""
    content = read_file(filepath)
    file_extension = filepath.suffix.lower()
    
    # Calculate original size
    original_size = len(content)
    
    # Minify content if possible
    minified_content = minify_content(content, file_extension)
    minified_size = len(minified_content)
    
    # Show minification results
    if MINIFY_AVAILABLE and minified_size < original_size:
        savings = original_size - minified_size
        percentage = (savings / original_size) * 100
        print(f"‚úÇÔ∏è  Minified {filepath.name}: {original_size} ‚Üí {minified_size} bytes ({savings} bytes saved, {percentage:.1f}%)")
    
    escaped_content = escape_for_raw_string(minified_content)
    
    return f"""
// Generated from: {filepath} (minified: {minified_size} bytes)
const char {var_name}[] PROGMEM = {escaped_content}
const size_t {var_name}_len = sizeof({var_name}) - 1;
"""

def generate_header():
    """Generate the header file with all embedded assets"""
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    web_dir = project_root / 'src' / 'web'
    generated_dir = project_root / 'src' / 'generated'
    
    # Create generated directory if it doesn't exist
    generated_dir.mkdir(exist_ok=True)
    
    header_content = """#ifndef FLEXIFI_WEB_ASSETS_H
#define FLEXIFI_WEB_ASSETS_H

/*
 * Auto-generated file containing embedded web assets for Flexifi
 * 
 * DO NOT EDIT MANUALLY!
 * 
 * This file is generated by tools/embed_assets.py
 * Re-run the script to update the embedded assets.
 */

#include <Arduino.h>

namespace FlexifiAssets {

"""

    # Embed HTML templates
    templates_dir = web_dir / 'templates'
    if templates_dir.exists():
        header_content += "    // HTML Templates\n"
        for html_file in templates_dir.glob('*.html'):
            var_name = f"template_{sanitize_var_name(html_file.name)}"
            header_content += embed_file(html_file, var_name)

    # Embed CSS files
    css_dir = web_dir / 'css'
    if css_dir.exists():
        header_content += "\n    // CSS Stylesheets\n"
        for css_file in css_dir.glob('*.css'):
            var_name = f"css_{sanitize_var_name(css_file.name)}"
            header_content += embed_file(css_file, var_name)

    # Embed JavaScript files
    js_dir = web_dir / 'js'
    if js_dir.exists():
        header_content += "\n    // JavaScript Files\n"
        for js_file in js_dir.glob('*.js'):
            var_name = f"js_{sanitize_var_name(js_file.name)}"
            header_content += embed_file(js_file, var_name)

    # Add asset lookup functions
    header_content += """
    // Asset lookup functions
    const char* getTemplate(const char* name);
    const char* getCSS(const char* name);
    const char* getJS(const char* name);
    
    // Asset size functions
    size_t getTemplateSize(const char* name);
    size_t getCSSSize(const char* name);
    size_t getJSSize(const char* name);

} // namespace FlexifiAssets

#endif // FLEXIFI_WEB_ASSETS_H
"""

    # Write the header file
    header_file = generated_dir / 'web_assets.h'
    with open(header_file, 'w', encoding='utf-8') as f:
        f.write(header_content)
    
    print(f"‚úÖ Generated: {header_file}")
    return header_file

def generate_implementation():
    """Generate the implementation file with lookup functions"""
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    web_dir = project_root / 'src' / 'web'
    generated_dir = project_root / 'src' / 'generated'
    
    impl_content = """#include "web_assets.h"
#include <string.h>

namespace FlexifiAssets {

const char* getTemplate(const char* name) {
"""

    # Add template lookup
    templates_dir = web_dir / 'templates'
    if templates_dir.exists():
        for html_file in templates_dir.glob('*.html'):
            name = sanitize_var_name(html_file.name)
            impl_content += f"""    if (strcmp(name, "{html_file.stem}") == 0) return template_{name};
"""

    impl_content += """    return nullptr;
}

const char* getCSS(const char* name) {
"""

    # Add CSS lookup
    css_dir = web_dir / 'css'
    if css_dir.exists():
        for css_file in css_dir.glob('*.css'):
            name = sanitize_var_name(css_file.name)
            impl_content += f"""    if (strcmp(name, "{css_file.stem}") == 0) return css_{name};
"""

    impl_content += """    return nullptr;
}

const char* getJS(const char* name) {
"""

    # Add JS lookup
    js_dir = web_dir / 'js'
    if js_dir.exists():
        for js_file in js_dir.glob('*.js'):
            name = sanitize_var_name(js_file.name)
            impl_content += f"""    if (strcmp(name, "{js_file.stem}") == 0) return js_{name};
"""

    impl_content += """    return nullptr;
}

// Size functions
size_t getTemplateSize(const char* name) {
"""

    # Add template size lookup
    if templates_dir.exists():
        for html_file in templates_dir.glob('*.html'):
            name = sanitize_var_name(html_file.name)
            impl_content += f"""    if (strcmp(name, "{html_file.stem}") == 0) return template_{name}_len;
"""

    impl_content += """    return 0;
}

size_t getCSSSize(const char* name) {
"""

    # Add CSS size lookup
    if css_dir.exists():
        for css_file in css_dir.glob('*.css'):
            name = sanitize_var_name(css_file.name)
            impl_content += f"""    if (strcmp(name, "{css_file.stem}") == 0) return css_{name}_len;
"""

    impl_content += """    return 0;
}

size_t getJSSize(const char* name) {
"""

    # Add JS size lookup
    if js_dir.exists():
        for js_file in js_dir.glob('*.js'):
            name = sanitize_var_name(js_file.name)
            impl_content += f"""    if (strcmp(name, "{js_file.stem}") == 0) return js_{name}_len;
"""

    impl_content += """    return 0;
}

} // namespace FlexifiAssets
"""

    # Write the implementation file
    impl_file = generated_dir / 'web_assets.cpp'
    with open(impl_file, 'w', encoding='utf-8') as f:
        f.write(impl_content)
    
    print(f"‚úÖ Generated: {impl_file}")
    return impl_file

def check_assets_exist():
    """Check if pre-generated assets exist"""
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    generated_dir = project_root / 'src' / 'generated'
    
    header_file = generated_dir / 'web_assets.h'
    impl_file = generated_dir / 'web_assets.cpp'
    
    return header_file.exists() and impl_file.exists()

def main():
    """Main entry point"""
    print("üîß Flexifi Asset Embedding Tool")
    print("=" * 40)
    
    # Show minification status
    if MINIFY_AVAILABLE:
        print("‚úÖ minify-html available - assets will be minified")
    else:
        print("‚ö†Ô∏è minify-html not available - assets will be embedded as-is")
        print("üí° Install with: pip install minify-html")
    print()
    
    try:
        # Check if we're in a package install context
        if len(sys.argv) > 1 and sys.argv[1] == "--check-only":
            if check_assets_exist():
                print("‚úÖ Pre-generated assets found, skipping embedding")
                return
            else:
                print("‚ö†Ô∏è No pre-generated assets found, running embedding...")
        
        # Check if pre-generated assets already exist (PlatformIO postinstall context)
        if check_assets_exist():
            print("‚úÖ Pre-generated assets already exist, skipping embedding")
            print("‚ÑπÔ∏è  To force regeneration, delete src/generated/ directory first")
            return
            
        header_file = generate_header()
        impl_file = generate_implementation()
        
        print("\n‚úÖ Asset embedding completed successfully!")
        print(f"üìÑ Header: {header_file}")
        print(f"üìÑ Implementation: {impl_file}")
        print("\nüí° Assets embedded and ready for compilation")
        
    except Exception as e:
        print(f"‚ùå Error during asset embedding: {e}")
        
        # In package install context, check for pre-generated assets
        if check_assets_exist():
            print("‚úÖ Found pre-generated assets, build can continue")
            print("‚ÑπÔ∏è  Asset embedding failed but fallback assets are available")
            sys.exit(0)
        else:
            print("‚ùå No pre-generated assets available and embedding failed")
            print("‚ÑπÔ∏è  Library may not function correctly without web assets")
            # Don't fail hard - let the build continue and show errors later
            sys.exit(0)

if __name__ == "__main__":
    main()