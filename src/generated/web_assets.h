#ifndef FLEXIFI_WEB_ASSETS_H
#define FLEXIFI_WEB_ASSETS_H

/*
 * Auto-generated file containing embedded web assets for Flexifi
 * 
 * DO NOT EDIT MANUALLY!
 * 
 * This file is generated by tools/embed_assets.py
 * Re-run the script to update the embedded assets.
 */

#include <Arduino.h>

namespace FlexifiAssets {

    // HTML Templates

// Generated from: /Users/andy/GitHub/andyshinn/flexifi/src/web/templates/modern.html (minified: 1338 bytes)
const char template_modern[] PROGMEM = R"FLEXIFI(<!doctype html><html lang=en><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>{{TITLE}}</title><style>{{CSS_MODERN}}</style><body><div class=container><div class=header><h1>{{TITLE}}</h1><p class=subtitle>Configure your WiFi connection</div><div class=status-panel><div id=status>{{STATUS}}</div></div><div class=wifi-panel><div class=networks-header><h2>Available Networks</h2><div class=button-group><button class="btn btn-secondary btn-compact" id=manualToggleBtn>Enter Manually</button><button class="btn btn-secondary btn-compact" id=scanBtn><span id=scanBtnText>Scan</span> <span class=spinner id=scanSpinner style=display:none>‚ü≥</span></button><button class="btn btn-danger btn-compact" id=resetBtn>Reset Configuration</button></div></div><div class=networks id=networks>{{NETWORKS}}</div></div><div class=connect-panel><div class=manual-form id=manualConnectForm style=display:none><h3>Manual Connection</h3><form id=connectForm><div class=form-group><label for=ssid>Network Name (SSID):</label><input id=ssid name=ssid required></div><div class=form-group><label for=password>Password:</label><input id=password name=password type=password></div> {{CUSTOM_PARAMETERS}} <button class="btn btn-primary btn-compact">Connect</button></form></div></div></div><script>{{JS_PORTAL}}</script>)FLEXIFI";
const size_t template_modern_len = sizeof(template_modern) - 1;

// Generated from: /Users/andy/GitHub/andyshinn/flexifi/src/web/templates/classic.html (minified: 740 bytes)
const char template_classic[] PROGMEM = R"FLEXIFI(<!doctype html><title>{{TITLE}}</title><meta content="width=device-width,initial-scale=1" name=viewport><style>{{CSS_CLASSIC}}</style><body><div class=container><h1>{{TITLE}}</h1><div class=panel><h2>Status</h2><div id=status>{{STATUS}}</div></div><div class=panel><h2>WiFi Networks</h2><button onclick=scanNetworks()>Scan</button><div id=networks>{{NETWORKS}}</div></div><div class=panel><h2>Connect</h2><form onsubmit="connectToWiFi(); return false;"><p><label>SSID:</label><br> <input id=ssid required><p><label>Password:</label><br> <input id=password type=password></p> {{CUSTOM_PARAMETERS}} <p><button>Connect</button></form></div><div class=panel><button onclick=resetConfig()>Reset</button></div></div><script>{{JS_PORTAL}}</script>)FLEXIFI";
const size_t template_classic_len = sizeof(template_classic) - 1;

// Generated from: /Users/andy/GitHub/andyshinn/flexifi/src/web/templates/minimal.html (minified: 526 bytes)
const char template_minimal[] PROGMEM = R"FLEXIFI(<!doctype html><title>{{TITLE}}</title><meta content="width=device-width,initial-scale=1" name=viewport><style>{{CSS_MINIMAL}}</style><body><h1>{{TITLE}}</h1><div id=status>{{STATUS}}</div><button onclick=scanNetworks()>Scan</button><div id=networks>{{NETWORKS}}</div><form onsubmit="connectToWiFi(); return false;">SSID: <input id=ssid required><br> Password: <input id=password type=password><br> {{CUSTOM_PARAMETERS}} <button>Connect</button></form><button onclick=resetConfig()>Reset</button><script>{{JS_PORTAL}}</script>)FLEXIFI";
const size_t template_minimal_len = sizeof(template_minimal) - 1;

    // CSS Stylesheets

// Generated from: /Users/andy/GitHub/andyshinn/flexifi/src/web/css/classic.css (minified: 794 bytes)
const char css_classic[] PROGMEM = R"FLEXIFI(body{background:#f5f5f5;margin:0;padding:20px;font-family:Arial,sans-serif}.container{background:#fff;border-radius:5px;max-width:600px;margin:0 auto;padding:20px;box-shadow:0 2px 10px #0000001a}h1{color:#333;text-align:center}h2{color:#666;border-bottom:2px solid #eee;padding-bottom:10px}.panel{border:1px solid #ddd;border-radius:5px;margin-bottom:20px;padding:15px}button{color:#fff;cursor:pointer;background:#007cba;border:none;border-radius:3px;padding:10px 20px}button:hover{background:#005a8b}input,select,textarea{border:1px solid #ddd;border-radius:3px;margin:5px 0;padding:8px}#status{background:#f0f0f0;border-radius:3px;margin:10px 0;padding:10px}.network-item{cursor:pointer;border:1px solid #eee;border-radius:3px;margin:5px 0;padding:10px}.network-item:hover{background:#f9f9f9})FLEXIFI";
const size_t css_classic_len = sizeof(css_classic) - 1;

// Generated from: /Users/andy/GitHub/andyshinn/flexifi/src/web/css/minimal.css (minified: 292 bytes)
const char css_minimal[] PROGMEM = R"FLEXIFI(body{margin:20px;font-family:Arial,sans-serif}button{margin:5px;padding:5px 10px}input,select,textarea{margin:2px;padding:5px}#status{background:#f0f0f0;margin:10px 0;padding:5px}.network-item{cursor:pointer;border:1px solid #ccc;margin:2px;padding:5px}.network-item:hover{background:#f5f5f5})FLEXIFI";
const size_t css_minimal_len = sizeof(css_minimal) - 1;

// Generated from: /Users/andy/GitHub/andyshinn/flexifi/src/web/css/modern.css (minified: 4825 bytes)
const char css_modern[] PROGMEM = R"FLEXIFI(*{box-sizing:border-box;margin:0;padding:0}body{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;padding:10px;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif}.container{background:#fff;border-radius:12px;max-width:600px;margin:0 auto;overflow:hidden;box-shadow:0 10px 30px #0003}.header{color:#fff;background:#4a5568;justify-content:space-between;align-items:center;padding:15px;display:flex}.header h1{margin-bottom:0;font-size:1.5em}.subtitle{opacity:.9}.status-panel,.wifi-panel,.connect-panel,.actions{padding:12px}.status-panel{padding:8px 12px}.status{border-radius:8px;padding:15px;font-weight:500}.status.ready{color:#065f46;background:#e6fffa}.status.scanning{color:#92400e;background:#fef3c7}.status.connecting{color:#1e40af;background:#dbeafe}.status.connected{color:#166534;background:#dcfce7}.status.failed,.status.error{color:#dc2626;background:#fee2e2}.status.throttled{color:#92400e;background:#fef3c7}.btn{cursor:pointer;border:none;border-radius:6px;padding:12px 24px;font-size:14px;font-weight:500;transition:all .2s}.btn-primary{color:#fff;background:#3b82f6}.btn-primary:hover{background:#2563eb}.btn-secondary{color:#fff;background:#6b7280}.btn-secondary:hover{background:#4b5563}.btn-danger{color:#fff;background:#ef4444}.btn-danger:hover{background:#dc2626}.form-group{align-items:center;gap:12px;margin-bottom:10px;display:flex}.form-group label{flex-shrink:0;min-width:120px;margin-bottom:0;font-weight:500}.form-group input,.form-group select,.form-group textarea{border:2px solid #e5e7eb;border-radius:6px;flex:1;padding:10px;font-size:16px}.form-group input:focus,.form-group select:focus,.form-group textarea:focus{border-color:#3b82f6;outline:none}.network-list{margin-top:15px}.network-item{cursor:pointer;border:1px solid #e5e7eb;border-radius:6px;justify-content:space-between;align-items:center;margin-bottom:8px;padding:12px;display:flex}.network-item:hover{background:#f9fafb}.network-name{font-weight:500}.network-info{color:#6b7280}.actions{text-align:center}.required{color:#dc2626}.manual-connect-toggle{text-align:center;margin-bottom:10px}.manual-form{padding-top:0}.manual-form h3{color:#374151;margin-bottom:8px;font-size:1em}.spinner{animation:1s linear infinite spin;display:inline-block}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.btn:disabled{opacity:.6;cursor:not-allowed}.network-item{padding:8px 12px}h2{margin-bottom:10px;font-size:1.2em}.networks-header{justify-content:space-between;align-items:center;margin-bottom:12px;display:flex}.networks-header h2{flex-grow:1;margin-bottom:0}.btn-compact{min-width:60px;padding:8px 16px;font-size:13px}.button-group{gap:8px;display:flex}.button-group .btn{margin:0}.signal-strength{vertical-align:middle;justify-content:flex-end;align-items:flex-end;width:auto;height:20px;margin:0;padding:2px;display:inline-flex}.signal-strength .bar{transform-origin:100% 100%;opacity:.3;background-color:#707070;border-radius:2px;width:4px;margin-left:2px;transition:all .3s cubic-bezier(.17,.67,.42,1.3);display:inline-block}.signal-strength .bar-1{height:20%}.signal-strength .bar-2{height:40%}.signal-strength .bar-3{height:60%}.signal-strength .bar-4{height:80%}.signal-strength .bar-5{height:100%}.signal-strength.strength-0 .bar{opacity:.2;background:#ef4444}.signal-strength.strength-1 .bar-1{opacity:1;background:#dc2626}.signal-strength.strength-1 .bar-2,.signal-strength.strength-1 .bar-3,.signal-strength.strength-1 .bar-4,.signal-strength.strength-1 .bar-5{opacity:.2;background:#707070}.signal-strength.strength-2 .bar-1,.signal-strength.strength-2 .bar-2{opacity:1;background:#ea580c}.signal-strength.strength-2 .bar-3,.signal-strength.strength-2 .bar-4,.signal-strength.strength-2 .bar-5{opacity:.2;background:#707070}.signal-strength.strength-3 .bar-1,.signal-strength.strength-3 .bar-2,.signal-strength.strength-3 .bar-3{opacity:1;background:#ca8a04}.signal-strength.strength-3 .bar-4,.signal-strength.strength-3 .bar-5{opacity:.2;background:#707070}.signal-strength.strength-4 .bar-1,.signal-strength.strength-4 .bar-2,.signal-strength.strength-4 .bar-3,.signal-strength.strength-4 .bar-4{opacity:1;background:#65a30d}.signal-strength.strength-4 .bar-5{opacity:.2;background:#707070}.signal-strength.strength-5 .bar-1,.signal-strength.strength-5 .bar-2,.signal-strength.strength-5 .bar-3,.signal-strength.strength-5 .bar-4,.signal-strength.strength-5 .bar-5{opacity:1;background:#16a34a}@keyframes signal-intro{0%{transform:scaleY(.3)}to{transform:scaleY(1)}}.signal-strength .bar{animation:.3s ease-out forwards signal-intro}.signal-strength .bar-1{animation-delay:50ms}.signal-strength .bar-2{animation-delay:.1s}.signal-strength .bar-3{animation-delay:.15s}.signal-strength .bar-4{animation-delay:.2s}.signal-strength .bar-5{animation-delay:.25s})FLEXIFI";
const size_t css_modern_len = sizeof(css_modern) - 1;

    // JavaScript Files

// Generated from: /Users/andy/GitHub/andyshinn/flexifi/src/web/js/portal.js (minified: 17578 bytes)
const char js_portal[] PROGMEM = R"FLEXIFI(let ws = null;
let scanInProgress = false;

function initWebSocket() {
    if ('WebSocket' in window) {
        console.log('Initializing WebSocket connection...');
        ws = new WebSocket('ws://' + window.location.host + '/ws');
        ws.onopen = function() { 
            console.log('‚úÖ WebSocket connected successfully'); 
        };
        ws.onmessage = function(event) { 
            console.log('üì® WebSocket message received:', event.data);
            handleWebSocketMessage(event.data); 
        };
        ws.onclose = function() { 
            console.log('‚ùå WebSocket disconnected, reconnecting...'); 
            setTimeout(initWebSocket, 5000); 
        };
        ws.onerror = function(error) { 
            console.log('‚ö†Ô∏è WebSocket error:', error); 
        };
    } else {
        console.log('‚ö†Ô∏è WebSocket not supported by browser');
    }
}

function handleWebSocketMessage(data) {
    try {
        const msg = JSON.parse(data);
        console.log('üì• WebSocket message received:', msg);
        
        if (msg.type === 'scan_complete') {
            if (msg.data.refresh_networks) {
                // New approach: refresh networks from API instead of receiving via WebSocket
                console.log('üîÑ Received refresh signal, fetching networks from API...');
                loadNetworksFromAPI();
            } else if (msg.data.networks) {
                // Legacy fallback for direct network data
                updateNetworks(msg.data.networks);
            }
            scanInProgress = false;
            updateScanButton(false); // Re-enable scan button
        } else if (msg.type === 'status_update') {
            updateStatus(msg.data.status, msg.data.message);
        } else if (msg.hasOwnProperty('success')) {
            // Handle scan response (success/failure/throttled)
            console.log('üìã WebSocket scan response:', msg);
            
            if (msg.success) {
                console.log('‚úÖ Scan initiated via WebSocket');
                // Keep scanning state - wait for scan_complete
            } else {
                // Scan failed or throttled
                console.log('‚ö†Ô∏è Scan failed via WebSocket:', msg.message);
                scanInProgress = false;
                updateScanButton(false); // Re-enable button
                
                if (msg.message && msg.message.includes('throttle')) {
                    updateStatus('throttled', msg.message);
                } else {
                    updateStatus('error', msg.message || 'Scan failed');
                }
                // Don't clear networks on scan failure - preserve existing results
            }
        }
    } catch (e) {
        console.error('Error parsing WebSocket message:', e);
    }
}

function scanNetworks() {
    if (scanInProgress) {
        console.log('‚ö†Ô∏è Scan already in progress, ignoring request');
        return;
    }
    
    console.log('üîç Starting network scan...');
    scanInProgress = true;
    updateScanButton(true); // Disable and show spinner
    updateStatus('scanning', 'Scanning for networks...');
    
    // Clear network list immediately when scan starts and ensure it's visible
    const networksList = document.getElementById('networks');
    const manualForm = document.getElementById('manualConnectForm');
    const toggleBtn = document.getElementById('manualToggleBtn');
    
    networksList.style.display = 'block';
    manualForm.style.display = 'none';
    toggleBtn.textContent = 'Enter Manually';
    updateNetworks([], true); // Pass isScanning=true to show scanning message
    
    if (ws && ws.readyState === WebSocket.OPEN) {
        console.log('üì§ Sending scan request via WebSocket');
        ws.send(JSON.stringify({action: 'scan'}));
    } else {
        console.log('üì§ WebSocket not available, using HTTP fetch');
        fetch('/scan')
            .then(response => {
                console.log('üì° Scan response status:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('üìã Scan data received:', data);
                scanInProgress = false;
                updateScanButton(false); // Re-enable button
                
                if (data.success && data.data) {
                    console.log('‚úÖ Scan successful, updating networks with:', data.data);
                    updateNetworks(data.data);
                } else if (data.message && data.message.includes('throttle')) {
                    // Handle throttled response
                    console.log('‚è≥ Scan throttled:', data.message);
                    updateStatus('throttled', data.message);
                    // Don't clear networks when throttled - preserve existing results
                } else {
                    console.log('‚ö†Ô∏è Scan response missing data or failed');
                    updateStatus('error', data.message || 'Scan failed');
                    // Don't clear networks on error - preserve existing results
                }
            })
            .catch(error => {
                console.error('‚ùå Scan error:', error);
                scanInProgress = false;
                updateScanButton(false); // Re-enable button
                updateStatus('error', 'Scan failed. Please try again.');
                // Don't clear networks on error - preserve existing results
            });
    }
}

function updateScanButton(scanning) {
    const scanBtn = document.getElementById('scanBtn');
    const scanBtnText = document.getElementById('scanBtnText');
    const scanSpinner = document.getElementById('scanSpinner');
    
    if (scanning) {
        scanBtn.disabled = true;
        scanBtnText.style.display = 'none';
        scanSpinner.style.display = 'inline-block';
    } else {
        scanBtn.disabled = false;
        scanBtnText.style.display = 'inline-block';
        scanSpinner.style.display = 'none';
    }
}

function selectNetwork(ssid) {
    document.getElementById('ssid').value = ssid;
    showManualForm(); // Automatically show the form when a network is selected
}

function showManualForm() {
    const manualForm = document.getElementById('manualConnectForm');
    const toggleBtn = document.getElementById('manualToggleBtn');
    const networksList = document.getElementById('networks');
    
    if (manualForm.style.display === 'none') {
        manualForm.style.display = 'block';
        toggleBtn.textContent = 'Hide Manual Entry';
        // Hide network list when manual entry is shown
        networksList.style.display = 'none';
    } else {
        manualForm.style.display = 'none';
        toggleBtn.textContent = 'Enter Manually';
        // Show network list when manual entry is hidden
        networksList.style.display = 'block';
    }
}

function connectToWiFi() {
    const ssid = document.getElementById('ssid').value;
    const password = document.getElementById('password').value;
    
    if (!ssid) {
        alert('Please enter a network name');
        return;
    }
    
    updateStatus('connecting', 'Connecting to ' + ssid + '...');
    
    const data = new FormData();
    data.append('ssid', ssid);
    data.append('password', password);
    
    // Add custom parameters to form data
    const form = document.getElementById('connectForm');
    if (form) {
        const formData = new FormData(form);
        for (let [key, value] of formData.entries()) {
            if (key !== 'ssid' && key !== 'password') {
                data.append(key, value);
            }
        }
    }
    
    fetch('/connect', {
        method: 'POST',
        body: data
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            updateStatus('connected', 'Connected successfully!');
            setTimeout(() => {
                window.location.href = '/';
            }, 3000);
        } else {
            updateStatus('failed', 'Connection failed: ' + data.message);
        }
    })
    .catch(error => {
        console.error('Connection error:', error);
        updateStatus('failed', 'Connection failed');
    });
}

function resetConfig() {
    if (confirm('Are you sure you want to reset the configuration?')) {
        fetch('/reset', {method: 'POST'})
            .then(() => {
                updateStatus('ready', 'Configuration reset');
                document.getElementById('ssid').value = '';
                document.getElementById('password').value = '';
                
                // Reset custom parameters
                const form = document.getElementById('connectForm');
                if (form) {
                    form.reset();
                }
            })
            .catch(error => console.error('Reset error:', error));
    }
}

function updateStatus(status, message) {
    const statusEl = document.getElementById('status');
    statusEl.className = 'status ' + status;
    statusEl.textContent = message || getStatusMessage(status);
}

function getStatusMessage(status) {
    switch(status) {
        case 'scanning': return 'üîÑ Scanning for networks...';
        case 'connecting': return '‚è≥ Connecting to network...';
        case 'connected': return '‚úÖ Connected successfully!';
        case 'failed': return '‚ùå Connection failed';
        case 'error': return '‚ùå Error occurred';
        case 'throttled': return '‚è≥ Scan throttled - please wait';
        default: return 'üîß Ready to configure';
    }
}

function createSignalStrengthIndicator(rssi) {
    // Convert RSSI to signal strength (0-5 bars) with granular WiFi ranges
    // 5-bar system provides more detailed signal quality representation
    let strength = 0;
    if (rssi >= -30) strength = 5;      // Exceptional: 5 bars, green (-30 and above)
    else if (rssi >= -50) strength = 4; // Excellent: 4 bars, yellow-green (-50 to -30)
    else if (rssi >= -60) strength = 3; // Good: 3 bars, yellow-orange (-60 to -50)  
    else if (rssi >= -70) strength = 2; // Fair: 2 bars, red-orange (-70 to -60)
    else if (rssi >= -80) strength = 1; // Poor: 1 bar, red (-80 to -70)
    else strength = 0;                  // Very poor: dim bars (below -80)
    
    const colorMap = {
        5: 'GREEN',
        4: 'YELLOW-GREEN', 
        3: 'YELLOW-ORANGE',
        2: 'RED-ORANGE',
        1: 'RED',
        0: 'DIM RED'
    };
    
    console.log('üì∂ RSSI:', rssi, '‚Üí Strength:', strength, '‚Üí Expected color:', colorMap[strength]);
    
    return '<div class="signal-strength strength-' + strength + '">' +
           '<span class="bar bar-1"></span>' +
           '<span class="bar bar-2"></span>' +
           '<span class="bar bar-3"></span>' +
           '<span class="bar bar-4"></span>' +
           '<span class="bar bar-5"></span>' +
           '</div>';
}

function updateNetworks(networks, isScanning = false) {
    console.log('üîÑ Updating networks UI with data:', networks, 'isScanning:', isScanning);
    const networksEl = document.getElementById('networks');
    
    if (isScanning) {
        // While scanning, show a scanning message instead of "No networks found"
        networksEl.innerHTML = '<p style="color: #92400e;">üîÑ Scanning...</p>';
        return;
    }
    
    if (!networks || networks.length === 0) {
        console.log('‚ö†Ô∏è No networks to display');
        networksEl.innerHTML = '<p>No networks found</p>';
        // Update status when no networks found (only if not currently scanning and no important status is showing)
        if (!scanInProgress) {
            const statusEl = document.getElementById('status');
            const currentStatus = statusEl.className;
            // Don't override error, throttled, or connecting statuses
            if (!currentStatus.includes('error') && !currentStatus.includes('throttled') && !currentStatus.includes('connecting')) {
                updateStatus('ready', 'No networks found. Try scanning again.');
            }
        }
        return;
    }
    
    // Update status when networks are found (always override any previous status)
    updateStatus('ready', 'Select a network or enter manually');
    
    console.log('‚úÖ Building HTML for', networks.length, 'networks');
    let html = '<div class="network-list">';
    networks.forEach(network => {
        const securityIcon = network.secure ? 'üîí' : 'üîì';
        // Use CSS signal strength indicator instead of emoji
        const signalStrength = createSignalStrengthIndicator(network.rssi || network.signal_strength || -70);
        
        html += '<div class="network-item" onclick="selectNetwork(\'' + 
                network.ssid.replace(/'/g, "\\'") + '\')">';
        html += '<span class="network-name">' + network.ssid + '</span>';
        html += '<span class="network-info">' + securityIcon + ' ' + signalStrength + '</span>';
        html += '</div>';
    });
    html += '</div>';
    networksEl.innerHTML = html;
    console.log('‚úÖ Networks UI updated successfully');
}

function selectNetwork(ssid) {
    console.log('üîó Network selected:', ssid);
    
    // Fill in the SSID field
    const ssidInput = document.getElementById('ssid');
    if (ssidInput) {
        ssidInput.value = ssid;
    }
    
    // Show the manual connection form
    const manualForm = document.getElementById('manualConnectForm');
    const toggleBtn = document.getElementById('manualToggleBtn');
    const networksList = document.getElementById('networks');
    
    if (manualForm && manualForm.style.display === 'none') {
        manualForm.style.display = 'block';
        if (toggleBtn) toggleBtn.textContent = 'Hide Manual Entry';
        if (networksList) networksList.style.display = 'none';
    }
    
    // Focus the password input after a brief delay to ensure the form is visible
    setTimeout(() => {
        const passwordInput = document.getElementById('password');
        if (passwordInput) {
            passwordInput.focus();
            console.log('üéØ Password field focused');
        }
    }, 100);
    
    // Update status
    updateStatus('ready', 'Enter password for ' + ssid);
}

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    initWebSocket();
    
    // Set up form submission
    const form = document.getElementById('connectForm');
    if (form) {
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            connectToWiFi();
        });
    }
    
    // Set up scan button
    const scanBtn = document.getElementById('scanBtn');
    if (scanBtn) {
        scanBtn.addEventListener('click', scanNetworks);
    }
    
    // Set up manual toggle button
    const manualToggleBtn = document.getElementById('manualToggleBtn');
    if (manualToggleBtn) {
        manualToggleBtn.addEventListener('click', showManualForm);
    }
    
    // Set up reset button
    const resetBtn = document.getElementById('resetBtn');
    if (resetBtn) {
        resetBtn.addEventListener('click', resetConfig);
    }
    
    // Load initial networks from server-side scan (if available)
    loadInitialNetworks();
    
    // If no networks are shown, do a scan
    setTimeout(function() {
        const networksEl = document.getElementById('networks');
        if (!networksEl.innerHTML || networksEl.innerHTML.trim() === '' || 
            networksEl.innerHTML.includes('Scanning for networks')) {
            scanNetworks();
        }
    }, 500);
});

function loadNetworksFromAPI() {
    console.log('üîÑ Loading networks from API...');
    
    fetch('/networks.json')
        .then(response => {
            console.log('üì° networks.json response status:', response.status);
            return response.json();
        })
        .then(data => {
            console.log('üìã networks.json data received:', data);
            
            if (data.networks && data.networks.length > 0) {
                console.log('‚úÖ Found', data.networks.length, 'networks, updating UI...');
                updateNetworks(data.networks);
                if (!scanInProgress) {
                    updateStatus('ready', 'Select a network or enter manually');
                }
            } else {
                console.log('‚ÑπÔ∏è No networks found');
                updateNetworks([]);
                if (!scanInProgress) {
                    updateStatus('ready', 'No networks found. Try scanning again.');
                }
            }
        })
        .catch(error => {
            console.log('‚ùå Error loading networks from API:', error);
            if (!scanInProgress) {
                updateStatus('ready', 'Click "Scan Networks" to find WiFi networks');
            }
        });
}

function loadInitialNetworks() {
    console.log('üîÑ Loading initial networks and status...');
    
    // First check status to see if scan is in progress
    fetch('/status')
        .then(response => response.json())
        .then(statusData => {
            console.log('üìä Status data received:', statusData);
            
            if (statusData.scan_in_progress) {
                console.log('üîÑ Scan is in progress, showing scan state...');
                scanInProgress = true;
                updateScanButton(true);
                updateStatus('scanning', 'Scanning for networks...');
            }
            
            // Load networks from API
            loadNetworksFromAPI();
        })
        .catch(error => {
            console.log('‚ùå Error loading initial data:', error);
            if (!scanInProgress) {
                updateStatus('ready', 'Click "Scan Networks" to find WiFi networks');
            }
        });
})FLEXIFI";
const size_t js_portal_len = sizeof(js_portal) - 1;

    // Asset lookup functions
    const char* getTemplate(const char* name);
    const char* getCSS(const char* name);
    const char* getJS(const char* name);
    
    // Asset size functions
    size_t getTemplateSize(const char* name);
    size_t getCSSSize(const char* name);
    size_t getJSSize(const char* name);

} // namespace FlexifiAssets

#endif // FLEXIFI_WEB_ASSETS_H
